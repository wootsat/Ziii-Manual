<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ziii Manual</title>
  <style>
    :root { --book-width: 90vmin; --speed: 220ms; } /* total flip time (both halves) */

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
    }

    #zoom-info{
      position: fixed;
      top: 10px;
      left: 10px;
      color: #777;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
    }

    #viewport{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
    }

    #drag-wrapper{
      position: absolute;
      transform-origin: center center;
      will-change: transform;
      cursor: grab;
      transform: translate3d(0,0,0) scale(1);
      touch-action: none;
    }
    #drag-wrapper:active{ cursor: grabbing; }

    .spread{
      position: relative;
      width: var(--book-width);
      height: calc(var(--book-width) * 0.7);
      background: #000;
      transform: translate3d(0,0,0);
    }

    .pageFrame{
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      overflow: hidden;
      background: #000;
    }

    .side{
      position: relative;
      overflow: hidden;
      background: #000;
    }

    .pageImg{
      position: absolute;
      inset: 0;
      background: #000;
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      transform: translate3d(0,0,0);
      will-change: transform;
    }

    .spine{
      position:absolute;
      left:50%;
      top:0;
      width:2px;
      height:100%;
      background: rgba(255,255,255,0.06);
      z-index: 30;
      pointer-events:none;
      opacity: 0.0;
    }

    .flipOverlay{
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 60;
      pointer-events: none;
      overflow: hidden;
      background: #000;
      transform: translate3d(0,0,0) scaleX(0);
      will-change: transform;
    }

    .curlFX{ position:absolute; inset:0; pointer-events:none; }

    .curlShadow{
      position:absolute; inset:0;
      pointer-events:none;
      opacity: 0.0;
      background: linear-gradient(to left, rgba(0,0,0,0.80), rgba(0,0,0,0.0));
    }

    .curlHighlight{
      position:absolute;
      top:0; bottom:0;
      width: 12px;
      pointer-events:none;
      opacity: 0.0;
      background: linear-gradient(to right,
        rgba(255,255,255,0.0),
        rgba(255,255,255,0.35),
        rgba(255,255,255,0.0));
    }

    .hit{
      position:absolute;
      inset:0;
      z-index: 100;
      pointer-events:auto;
      background: transparent;
    }
  </style>
</head>

<body>
  <div id="zoom-info">Scroll: Zoom to Cursor | Drag: Move | Click Right: Next | Click Left: Prev</div>

  <div id="viewport">
    <div id="drag-wrapper">
      <div class="spread">
        <div class="pageFrame" id="frame">
          <div class="side"><div class="pageImg" id="leftImg"></div></div>
          <div class="side"><div class="pageImg" id="rightImg"></div></div>

          <div class="spine"></div>

          <div class="flipOverlay" id="flipRight">
            <div class="pageImg" id="flipRightImg"></div>
            <div class="curlFX">
              <div class="curlShadow" id="fxRightShadow"></div>
              <div class="curlHighlight" id="fxRightHi"></div>
            </div>
          </div>

          <div class="flipOverlay" id="flipLeft">
            <div class="pageImg" id="flipLeftImg"></div>
            <div class="curlFX">
              <div class="curlShadow" id="fxLeftShadow"></div>
              <div class="curlHighlight" id="fxLeftHi"></div>
            </div>
          </div>

          <div class="hit" id="hit"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const totalImages = 58;
    const folderPath = "images/";
    const extension = ".jpg";

    const TOTAL_SPEED = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--speed")) || 280;
    const HALF_SPEED = Math.max(60, Math.floor(TOTAL_SPEED / 2));
    const maxSpread = Math.ceil((totalImages + 1) / 2) - 1;

    const frame = document.getElementById("frame");
    const dragWrapper = document.getElementById("drag-wrapper");

    const leftImg = document.getElementById("leftImg");
    const rightImg = document.getElementById("rightImg");

    const flipRight = document.getElementById("flipRight");
    const flipRightImg = document.getElementById("flipRightImg");
    const fxRightShadow = document.getElementById("fxRightShadow");
    const fxRightHi = document.getElementById("fxRightHi");

    const flipLeft = document.getElementById("flipLeft");
    const flipLeftImg = document.getElementById("flipLeftImg");
    const fxLeftShadow = document.getElementById("fxLeftShadow");
    const fxLeftHi = document.getElementById("fxLeftHi");

    const hit = document.getElementById("hit");

    // ---- Drag/Zoom ----
    const DRAG_THRESHOLD = 6;
    let scale = 1;
    let pos = { x: 0, y: 0 };
    let isDragging = false;
    let wasDragged = false;
    let startMouse = { x: 0, y: 0 };
    let dragStart = { x: 0, y: 0 };

    function updateTransform() {
      dragWrapper.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0) scale(${scale})`;
    }

    window.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newScale = Math.min(Math.max(0.1, scale * delta), 6);

      const mouseX = e.clientX - window.innerWidth / 2;
      const mouseY = e.clientY - window.innerHeight / 2;

      pos.x = mouseX - (mouseX - pos.x) * (newScale / scale);
      pos.y = mouseY - (mouseY - pos.y) * (newScale / scale);

      scale = newScale;
      updateTransform();
    }, { passive: false });

    window.addEventListener("mousedown", (e) => {
      isDragging = true;
      wasDragged = false;
      dragStart = { x: e.clientX, y: e.clientY };
      startMouse = { x: e.clientX - pos.x, y: e.clientY - pos.y };
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      if (!wasDragged && Math.hypot(dx, dy) > DRAG_THRESHOLD) wasDragged = true;

      if (wasDragged) {
        pos.x = e.clientX - startMouse.x;
        pos.y = e.clientY - startMouse.y;
        updateTransform();
      }
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      setTimeout(() => { wasDragged = false; }, 50);
    });

    // ---- Images ----
    function srcFor(index) {
      if (index < 0 || index >= totalImages) return null;
      return `${folderPath}${index}${extension}`;
    }
    function setBg(el, url) {
      el.style.backgroundImage = url ? `url("${url}")` : "none";
    }
    function spreadToIndices(spreadIndex) {
      const right = spreadIndex * 2;
      const left  = right - 1;
      return { left, right };
    }
    function renderSpread(i) {
      const { left, right } = spreadToIndices(i);
      setBg(leftImg, srcFor(left));
      setBg(rightImg, srcFor(right));
    }

    // ---- PRELOAD/DECODE CACHE (fixes "black until loaded" on first flip) ----
    const preloadCache = new Map(); // url -> Promise

    function preloadAndDecode(url) {
      if (!url) return Promise.resolve();
      if (preloadCache.has(url)) return preloadCache.get(url);

      const p = new Promise((resolve) => {
        const img = new Image();
        // same-origin on GitHub Pages; no crossOrigin needed unless you later draw to canvas
        img.onload = async () => {
          // decode() prevents the "loaded but not decoded yet" black flash
          if (img.decode) {
            try { await img.decode(); } catch (_) {}
          }
          resolve();
        };
        img.onerror = () => resolve(); // fail soft; still allow flipping
        img.src = url;
      });

      preloadCache.set(url, p);
      return p;
    }

    // Preload a few upcoming pages so first interaction is smooth
    function warmStart() {
      const urls = [];
      for (let i = 0; i < Math.min(totalImages, 8); i++) urls.push(srcFor(i));
      urls.forEach(u => preloadAndDecode(u));
    }

    // ---- Sequential flip ----
    let spreadIndex = 0;
    let animating = false;

    function easeInQuad(t){ return t * t; }
    function easeOutQuad(t){ return 1 - (1 - t) * (1 - t); }

    function setOverlay(overlayEl, side, origin, imgEl, imgUrl, scaleX){
      overlayEl.style.left = (side === "left") ? "0%" : "50%";
      overlayEl.style.transformOrigin = origin;
      setBg(imgEl, imgUrl);
      overlayEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX})`;
    }

    function setCurlFX(fold01, shadowEl, hiEl, dir){
      const mid = 1 - Math.abs(fold01 - 0.5) * 2;
      shadowEl.style.opacity = (0.22 + mid * 0.58).toFixed(3);
      hiEl.style.opacity     = (0.05 + mid * 0.22).toFixed(3);

      if (dir === "next") {
        hiEl.style.left = "0px";
        shadowEl.style.background = "linear-gradient(to left, rgba(0,0,0,0.80), rgba(0,0,0,0.0))";
      } else {
        hiEl.style.left = "calc(100% - 12px)";
        shadowEl.style.background = "linear-gradient(to right, rgba(0,0,0,0.80), rgba(0,0,0,0.0))";
      }
    }

    function resetOverlay(overlayEl, shadowEl, hiEl){
      overlayEl.style.transform = "translate3d(0,0,0) scaleX(0)";
      shadowEl.style.opacity = "0";
      hiEl.style.opacity = "0";
    }

    function animateHalf(overlayEl, fromSX, toSX, dirForFX, shadowEl, hiEl, easingFn){
      return new Promise((resolve) => {
        const start = performance.now();
        function tick(now){
          const raw = Math.min(1, (now - start) / HALF_SPEED);
          const t = easingFn(raw);
          const sx = fromSX + (toSX - fromSX) * t;
          overlayEl.style.transform = `translate3d(0,0,0) scaleX(${sx})`;

          const folding = fromSX > toSX;
          const fold01 = folding ? t : (1 - t);
          setCurlFX(fold01, shadowEl, hiEl, dirForFX);

          if (raw < 1) requestAnimationFrame(tick);
          else resolve();
        }
        requestAnimationFrame(tick);
      });
    }

    async function next(){
      if (animating) return;
      if (spreadIndex >= maxSpread) return;
      animating = true;

      const curr = spreadIndex;
      const nextIdx = curr + 1;

      const currPair = spreadToIndices(curr);
      const nextPair = spreadToIndices(nextIdx);

      const currLeftUrl  = srcFor(currPair.left);
      const currRightUrl = srcFor(currPair.right);
      const nextLeftUrl  = srcFor(nextPair.left);
      const nextRightUrl = srcFor(nextPair.right);

      // CRITICAL: ensure Phase-B image is decoded before we need it
      await Promise.all([
        preloadAndDecode(nextLeftUrl),
        preloadAndDecode(nextRightUrl)
      ]);

      // Underlay setup
      setBg(leftImg, currLeftUrl);
      setBg(rightImg, nextRightUrl);

      // Phase A: fold current RIGHT page into spine
      setOverlay(flipRight, "right", "left center", flipRightImg, currRightUrl, 1);
      flipRight.style.zIndex = "70";
      await animateHalf(flipRight, 1, 0, "next", fxRightShadow, fxRightHi, easeInQuad);

      // Phase B: unfold new LEFT page from spine
      setOverlay(flipLeft, "left", "right center", flipLeftImg, nextLeftUrl, 0);
      flipLeft.style.zIndex = "71";
      await animateHalf(flipLeft, 0, 1, "prev", fxLeftShadow, fxLeftHi, easeOutQuad);

      spreadIndex = nextIdx;
      renderSpread(spreadIndex);

      resetOverlay(flipRight, fxRightShadow, fxRightHi);
      resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
      animating = false;

      // Opportunistic preload of the next spread
      const ahead = spreadToIndices(Math.min(maxSpread, spreadIndex + 1));
      preloadAndDecode(srcFor(ahead.left));
      preloadAndDecode(srcFor(ahead.right));
    }

    async function prev(){
      if (animating) return;
      if (spreadIndex <= 0) return;
      animating = true;

      const curr = spreadIndex;
      const prevIdx = curr - 1;

      const currPair = spreadToIndices(curr);
      const prevPair = spreadToIndices(prevIdx);

      const currLeftUrl  = srcFor(currPair.left);
      const currRightUrl = srcFor(currPair.right);
      const prevLeftUrl  = srcFor(prevPair.left);
      const prevRightUrl = srcFor(prevPair.right);

      // CRITICAL: ensure Phase-B image is decoded before we need it
      await Promise.all([
        preloadAndDecode(prevRightUrl),
        preloadAndDecode(prevLeftUrl)
      ]);

      // Underlay setup
      setBg(leftImg, prevLeftUrl);
      setBg(rightImg, currRightUrl);

      // Phase A: fold current LEFT page into spine
      setOverlay(flipLeft, "left", "right center", flipLeftImg, currLeftUrl, 1);
      flipLeft.style.zIndex = "70";
      await animateHalf(flipLeft, 1, 0, "prev", fxLeftShadow, fxLeftHi, easeInQuad);

      // Phase B: unfold previous RIGHT page from spine
      setOverlay(flipRight, "right", "left center", flipRightImg, prevRightUrl, 0);
      flipRight.style.zIndex = "71";
      await animateHalf(flipRight, 0, 1, "next", fxRightShadow, fxRightHi, easeOutQuad);

      spreadIndex = prevIdx;
      renderSpread(spreadIndex);

      resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
      resetOverlay(flipRight, fxRightShadow, fxRightHi);
      animating = false;

      // Opportunistic preload (behind)
      const behind = spreadToIndices(Math.max(0, spreadIndex - 1));
      preloadAndDecode(srcFor(behind.left));
      preloadAndDecode(srcFor(behind.right));
    }

    hit.addEventListener("click", (e) => {
      if (wasDragged) return;
      if (animating) return;

      const r = frame.getBoundingClientRect();
      const x = e.clientX - r.left;
      if (x > r.width / 2) next();
      else prev();
    });

    // Init
    renderSpread(spreadIndex);
    updateTransform();
    resetOverlay(flipRight, fxRightShadow, fxRightHi);
    resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
    warmStart();
  </script>
</body>
</html>

