<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ziii Manual</title>
  <style>
    :root { --book-width: 90vmin; --speed: 220ms; } /* total flip time */

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
      /* Important: we will handle pan/zoom ourselves */
      touch-action: none;
    }

    #zoom-info{
      position: fixed;
      top: 10px;
      left: 10px;
      color: #777;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
    }

    #viewport{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      touch-action: none;
    }

    #drag-wrapper{
      position: absolute;
      transform-origin: center center;
      will-change: transform;
      cursor: grab;
      transform: translate3d(0,0,0) scale(1);
      touch-action: none;
    }
    #drag-wrapper:active{ cursor: grabbing; }

    .spread{
      position: relative;
      width: var(--book-width);
      height: calc(var(--book-width) * 0.7);
      background: #000;
      transform: translate3d(0,0,0);
    }

    .pageFrame{
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      overflow: hidden;
      background: #000;
    }

    .side{
      position: relative;
      overflow: hidden;
      background: #000;
    }

    .pageImg{
      position: absolute;
      inset: 0;
      background: #000;
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      transform: translate3d(0,0,0);
      will-change: transform;
    }

    .spine{
      position:absolute;
      left:50%;
      top:0;
      width:2px;
      height:100%;
      background: rgba(255,255,255,0.06);
      z-index: 30;
      pointer-events:none;
      opacity: 0.0;
    }

    .flipOverlay{
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 60;
      pointer-events: none;
      overflow: hidden;
      background: #000;
      transform: translate3d(0,0,0) scaleX(0);
      will-change: transform;
    }

    .curlFX{ position:absolute; inset:0; pointer-events:none; }

    .curlShadow{
      position:absolute; inset:0;
      pointer-events:none;
      opacity: 0.0;
      background: linear-gradient(to left, rgba(0,0,0,0.80), rgba(0,0,0,0.0));
    }

    .curlHighlight{
      position:absolute;
      top:0; bottom:0;
      width: 12px;
      pointer-events:none;
      opacity: 0.0;
      background: linear-gradient(to right,
        rgba(255,255,255,0.0),
        rgba(255,255,255,0.35),
        rgba(255,255,255,0.0));
    }

    /* Click/tap capture. Keep it, but allow our custom gestures everywhere */
    .hit{
      position:absolute;
      inset:0;
      z-index: 100;
      pointer-events:auto;
      background: transparent;
      touch-action: none; /* crucial */
    }
  </style>
</head>

<body>
  <div id="zoom-info">Pinch: Zoom | 1-finger drag: Move | Tap Right: Next | Tap Left: Prev</div>

  <div id="viewport">
    <div id="drag-wrapper">
      <div class="spread">
        <div class="pageFrame" id="frame">
          <div class="side"><div class="pageImg" id="leftImg"></div></div>
          <div class="side"><div class="pageImg" id="rightImg"></div></div>

          <div class="spine"></div>

          <div class="flipOverlay" id="flipRight">
            <div class="pageImg" id="flipRightImg"></div>
            <div class="curlFX">
              <div class="curlShadow" id="fxRightShadow"></div>
              <div class="curlHighlight" id="fxRightHi"></div>
            </div>
          </div>

          <div class="flipOverlay" id="flipLeft">
            <div class="pageImg" id="flipLeftImg"></div>
            <div class="curlFX">
              <div class="curlShadow" id="fxLeftShadow"></div>
              <div class="curlHighlight" id="fxLeftHi"></div>
            </div>
          </div>

          <div class="hit" id="hit"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const totalImages = 58;
    const folderPath = "images/";
    const extension = ".jpg";

    const TOTAL_SPEED = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--speed")) || 280;
    const HALF_SPEED = Math.max(60, Math.floor(TOTAL_SPEED / 2));
    const maxSpread = Math.ceil((totalImages + 1) / 2) - 1;

    const frame = document.getElementById("frame");
    const dragWrapper = document.getElementById("drag-wrapper");

    const leftImg = document.getElementById("leftImg");
    const rightImg = document.getElementById("rightImg");

    const flipRight = document.getElementById("flipRight");
    const flipRightImg = document.getElementById("flipRightImg");
    const fxRightShadow = document.getElementById("fxRightShadow");
    const fxRightHi = document.getElementById("fxRightHi");

    const flipLeft = document.getElementById("flipLeft");
    const flipLeftImg = document.getElementById("flipLeftImg");
    const fxLeftShadow = document.getElementById("fxLeftShadow");
    const fxLeftHi = document.getElementById("fxLeftHi");

    const hit = document.getElementById("hit");

    // ---------------- PAN + ZOOM (mouse + touch pinch) ----------------
    const DRAG_THRESHOLD = 6;

    let scale = 1;
    let pos = { x: 0, y: 0 };

    // Pointer tracking (works for touch + pen)
    const pointers = new Map(); // id -> {x,y, startX,startY}
    let isPanning = false;
    let wasDragged = false;

    // Pinch state
    let pinching = false;
    let pinchStartDist = 0;
    let pinchStartScale = 1;
    let pinchStartPos = { x: 0, y: 0 };
    let pinchStartMid = { x: 0, y: 0 };

    function updateTransform() {
      dragWrapper.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0) scale(${scale})`;
    }

    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function getMidAndDist(p1, p2) {
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const dist = Math.hypot(dx, dy);
      return { midX, midY, dist };
    }

    // Convert screen point to "world" anchor approach (zoom to point)
    function zoomToPoint(newScale, clientX, clientY) {
      newScale = clamp(newScale, 0.1, 6);

      // point relative to screen center
      const px = clientX - window.innerWidth / 2;
      const py = clientY - window.innerHeight / 2;

      // Keep the point under the fingers stable
      pos.x = px - (px - pos.x) * (newScale / scale);
      pos.y = py - (py - pos.y) * (newScale / scale);

      scale = newScale;
      updateTransform();
    }

    // Desktop wheel zoom (still useful)
    window.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoomToPoint(scale * delta, e.clientX, e.clientY);
    }, { passive: false });

    // Pointer events for pan + pinch everywhere (including on the book)
    window.addEventListener("pointerdown", (e) => {
      // capture so moves continue even if finger leaves element
      try { e.target.setPointerCapture(e.pointerId); } catch (_) {}

      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, startX: e.clientX, startY: e.clientY });
      wasDragged = false;

      if (pointers.size === 1) {
        isPanning = true;
        pinching = false;
      } else if (pointers.size === 2) {
        // Start pinch
        pinching = true;
        isPanning = false;

        const pts = Array.from(pointers.values());
        const { midX, midY, dist } = getMidAndDist(pts[0], pts[1]);

        pinchStartDist = dist || 1;
        pinchStartScale = scale;
        pinchStartPos = { ...pos };
        pinchStartMid = { x: midX, y: midY };

        // Also set up the "zoom to midpoint" anchor
        // (we'll use zoomToPoint-like logic but based on start state)
      }
    }, { passive: false });

    window.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;

      // update pointer
      const p = pointers.get(e.pointerId);
      p.x = e.clientX;
      p.y = e.clientY;

      if (pointers.size === 2) {
        // pinch zoom
        pinching = true;
        isPanning = false;

        const pts = Array.from(pointers.values());
        const { midX, midY, dist } = getMidAndDist(pts[0], pts[1]);

        const ratio = (dist || 1) / pinchStartDist;
        const newScale = clamp(pinchStartScale * ratio, 0.1, 6);

        // Apply "zoom to midpoint" but using start pos/scale to avoid drift
        const px = midX - window.innerWidth / 2;
        const py = midY - window.innerHeight / 2;

        pos.x = px - (px - pinchStartPos.x) * (newScale / pinchStartScale);
        pos.y = py - (py - pinchStartPos.y) * (newScale / pinchStartScale);

        scale = newScale;
        updateTransform();

        e.preventDefault();
        return;
      }

      if (pointers.size === 1 && isPanning && !pinching) {
        const only = Array.from(pointers.values())[0];
        const dx = only.x - only.startX;
        const dy = only.y - only.startY;

        if (!wasDragged && Math.hypot(dx, dy) > DRAG_THRESHOLD) wasDragged = true;

        if (wasDragged) {
          pos.x += (e.movementX || 0);
          pos.y += (e.movementY || 0);

          // movementX/movementY can be 0 on some mobile browsers; fallback:
          if (!e.movementX && !e.movementY) {
            // use delta from last stored position
            const prev = pointers.get(e.pointerId)._prev || { x: only.x, y: only.y };
            pos.x += (only.x - prev.x);
            pos.y += (only.y - prev.y);
          }

          pointers.get(e.pointerId)._prev = { x: only.x, y: only.y };
          updateTransform();
        }

        e.preventDefault();
      }
    }, { passive: false });

    window.addEventListener("pointerup", (e) => {
      pointers.delete(e.pointerId);

      if (pointers.size < 2) pinching = false;
      if (pointers.size === 0) {
        isPanning = false;
        setTimeout(() => { wasDragged = false; }, 50);
      }
    }, { passive: false });

    window.addEventListener("pointercancel", (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) pinching = false;
      if (pointers.size === 0) isPanning = false;
    }, { passive: false });

    // ---------------- IMAGES ----------------
    function srcFor(index) {
      if (index < 0 || index >= totalImages) return null;
      return `${folderPath}${index}${extension}`;
    }
    function setBg(el, url) {
      el.style.backgroundImage = url ? `url("${url}")` : "none";
    }
    function spreadToIndices(spreadIndex) {
      const right = spreadIndex * 2;
      const left  = right - 1;
      return { left, right };
    }
    function renderSpread(i) {
      const { left, right } = spreadToIndices(i);
      setBg(leftImg, srcFor(left));
      setBg(rightImg, srcFor(right));
    }

    // ---- PRELOAD/DECODE CACHE (prevents black on first load) ----
    const preloadCache = new Map();
    function preloadAndDecode(url) {
      if (!url) return Promise.resolve();
      if (preloadCache.has(url)) return preloadCache.get(url);

      const p = new Promise((resolve) => {
        const img = new Image();
        img.onload = async () => {
          if (img.decode) { try { await img.decode(); } catch (_) {} }
          resolve();
        };
        img.onerror = () => resolve();
        img.src = url;
      });
      preloadCache.set(url, p);
      return p;
    }
    function warmStart() {
      const urls = [];
      for (let i = 0; i < Math.min(totalImages, 10); i++) urls.push(srcFor(i));
      urls.forEach(u => preloadAndDecode(u));
    }

    // ---------------- PAGE TURN (sequential halves) ----------------
    let spreadIndex = 0;
    let animating = false;

    function easeInQuad(t){ return t * t; }
    function easeOutQuad(t){ return 1 - (1 - t) * (1 - t); }

    function setOverlay(overlayEl, side, origin, imgEl, imgUrl, scaleX){
      overlayEl.style.left = (side === "left") ? "0%" : "50%";
      overlayEl.style.transformOrigin = origin;
      setBg(imgEl, imgUrl);
      overlayEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX})`;
    }

    function setCurlFX(fold01, shadowEl, hiEl, dir){
      const mid = 1 - Math.abs(fold01 - 0.5) * 2;
      shadowEl.style.opacity = (0.22 + mid * 0.58).toFixed(3);
      hiEl.style.opacity     = (0.05 + mid * 0.22).toFixed(3);

      if (dir === "next") {
        hiEl.style.left = "0px";
        shadowEl.style.background = "linear-gradient(to left, rgba(0,0,0,0.80), rgba(0,0,0,0.0))";
      } else {
        hiEl.style.left = "calc(100% - 12px)";
        shadowEl.style.background = "linear-gradient(to right, rgba(0,0,0,0.80), rgba(0,0,0,0.0))";
      }
    }

    function resetOverlay(overlayEl, shadowEl, hiEl){
      overlayEl.style.transform = "translate3d(0,0,0) scaleX(0)";
      shadowEl.style.opacity = "0";
      hiEl.style.opacity = "0";
    }

    function animateHalf(overlayEl, fromSX, toSX, dirForFX, shadowEl, hiEl, easingFn){
      return new Promise((resolve) => {
        const start = performance.now();
        function tick(now){
          const raw = Math.min(1, (now - start) / HALF_SPEED);
          const t = easingFn(raw);
          const sx = fromSX + (toSX - fromSX) * t;
          overlayEl.style.transform = `translate3d(0,0,0) scaleX(${sx})`;

          const folding = fromSX > toSX;
          const fold01 = folding ? t : (1 - t);
          setCurlFX(fold01, shadowEl, hiEl, dirForFX);

          if (raw < 1) requestAnimationFrame(tick);
          else resolve();
        }
        requestAnimationFrame(tick);
      });
    }

    async function next(){
      if (animating) return;
      if (spreadIndex >= maxSpread) return;
      animating = true;

      const curr = spreadIndex;
      const nextIdx = curr + 1;

      const currPair = spreadToIndices(curr);
      const nextPair = spreadToIndices(nextIdx);

      const currLeftUrl  = srcFor(currPair.left);
      const currRightUrl = srcFor(currPair.right);
      const nextLeftUrl  = srcFor(nextPair.left);
      const nextRightUrl = srcFor(nextPair.right);

      await Promise.all([preloadAndDecode(nextLeftUrl), preloadAndDecode(nextRightUrl)]);

      // Underlay setup
      setBg(leftImg, currLeftUrl);
      setBg(rightImg, nextRightUrl);

      // Phase A: fold current RIGHT page into spine
      setOverlay(flipRight, "right", "left center", flipRightImg, currRightUrl, 1);
      flipRight.style.zIndex = "70";
      await animateHalf(flipRight, 1, 0, "next", fxRightShadow, fxRightHi, easeInQuad);

      // Phase B: unfold new LEFT page from spine
      setOverlay(flipLeft, "left", "right center", flipLeftImg, nextLeftUrl, 0);
      flipLeft.style.zIndex = "71";
      await animateHalf(flipLeft, 0, 1, "prev", fxLeftShadow, fxLeftHi, easeOutQuad);

      spreadIndex = nextIdx;
      renderSpread(spreadIndex);

      resetOverlay(flipRight, fxRightShadow, fxRightHi);
      resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
      animating = false;

      // preload ahead
      const ahead = spreadToIndices(Math.min(maxSpread, spreadIndex + 1));
      preloadAndDecode(srcFor(ahead.left));
      preloadAndDecode(srcFor(ahead.right));
    }

    async function prev(){
      if (animating) return;
      if (spreadIndex <= 0) return;
      animating = true;

      const curr = spreadIndex;
      const prevIdx = curr - 1;

      const currPair = spreadToIndices(curr);
      const prevPair = spreadToIndices(prevIdx);

      const currLeftUrl  = srcFor(currPair.left);
      const currRightUrl = srcFor(currPair.right);
      const prevLeftUrl  = srcFor(prevPair.left);
      const prevRightUrl = srcFor(prevPair.right);

      await Promise.all([preloadAndDecode(prevRightUrl), preloadAndDecode(prevLeftUrl)]);

      // Underlay setup
      setBg(leftImg, prevLeftUrl);
      setBg(rightImg, currRightUrl);

      // Phase A: fold current LEFT page into spine
      setOverlay(flipLeft, "left", "right center", flipLeftImg, currLeftUrl, 1);
      flipLeft.style.zIndex = "70";
      await animateHalf(flipLeft, 1, 0, "prev", fxLeftShadow, fxLeftHi, easeInQuad);

      // Phase B: unfold previous RIGHT page from spine
      setOverlay(flipRight, "right", "left center", flipRightImg, prevRightUrl, 0);
      flipRight.style.zIndex = "71";
      await animateHalf(flipRight, 0, 1, "next", fxRightShadow, fxRightHi, easeOutQuad);

      spreadIndex = prevIdx;
      renderSpread(spreadIndex);

      resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
      resetOverlay(flipRight, fxRightShadow, fxRightHi);
      animating = false;

      // preload behind
      const behind = spreadToIndices(Math.max(0, spreadIndex - 1));
      preloadAndDecode(srcFor(behind.left));
      preloadAndDecode(srcFor(behind.right));
    }

    // Tap to flip (ignore if user dragged/pinched)
    hit.addEventListener("click", (e) => {
      if (wasDragged || pinching) return;
      if (animating) return;

      const r = frame.getBoundingClientRect();
      const x = e.clientX - r.left;
      if (x > r.width / 2) next();
      else prev();
    });

    // Init
    renderSpread(spreadIndex);
    updateTransform();
    resetOverlay(flipRight, fxRightShadow, fxRightHi);
    resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
    warmStart();
  </script>
</body>
</html>
