<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ziii Manual</title>
  <style>
    :root { --book-width: 90vmin; --speed: 280ms; } /* total flip time */

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
      touch-action: none; /* we handle pan/zoom */
    }

    #zoom-info{
      position: fixed;
      top: 10px;
      left: 10px;
      color: #777;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
    }

    #viewport{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      touch-action: none;
    }

    #drag-wrapper{
      position: absolute;
      transform-origin: center center;
      will-change: transform;
      cursor: grab;
      transform: translate3d(0,0,0) scale(1);
      touch-action: none;
    }
    #drag-wrapper:active{ cursor: grabbing; }

    .spread{
      position: relative;
      width: var(--book-width);
      height: calc(var(--book-width) * 0.7);
      background: #000;
      transform: translate3d(0,0,0);
    }

    .pageFrame{
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      overflow: hidden;
      background: #000;
    }

    .side{
      position: relative;
      overflow: hidden;
      background: #000;
    }

    .pageImg{
      position: absolute;
      inset: 0;
      background: #000;
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      transform: translate3d(0,0,0);
      will-change: transform;
    }

    .spine{
      position:absolute;
      left:50%;
      top:0;
      width:2px;
      height:100%;
      background: rgba(255,255,255,0.06);
      z-index: 30;
      pointer-events:none;
      opacity: 0.0; /* set to 0.06 if you want a faint spine */
    }

    .flipOverlay{
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 60;
      pointer-events: none;
      overflow: hidden;
      background: #000;
      transform: translate3d(0,0,0) scaleX(0);
      will-change: transform;
    }

    .curlFX{ position:absolute; inset:0; pointer-events:none; }

    .curlShadow{
      position:absolute; inset:0;
      pointer-events:none;
      opacity: 0.0;
      background: linear-gradient(to left, rgba(0,0,0,0.80), rgba(0,0,0,0.0));
    }

    .curlHighlight{
      position:absolute;
      top:0; bottom:0;
      width: 12px;
      pointer-events:none;
      opacity: 0.0;
      background: linear-gradient(to right,
        rgba(255,255,255,0.0),
        rgba(255,255,255,0.35),
        rgba(255,255,255,0.0));
    }

    .hit{
      position:absolute;
      inset:0;
      z-index: 100;
      pointer-events:auto;
      background: transparent;
      touch-action: none; /* allow our custom pinch anywhere */
    }
  </style>
</head>

<body>
  <div id="zoom-info">Pinch: Zoom | 1-finger drag: Move | Wheel: Zoom | Tap Right: Next | Tap Left: Prev</div>

  <div id="viewport">
    <div id="drag-wrapper">
      <div class="spread">
        <div class="pageFrame" id="frame">
          <div class="side"><div class="pageImg" id="leftImg"></div></div>
          <div class="side"><div class="pageImg" id="rightImg"></div></div>

          <div class="spine"></div>

          <div class="flipOverlay" id="flipRight">
            <div class="pageImg" id="flipRightImg"></div>
            <div class="curlFX">
              <div class="curlShadow" id="fxRightShadow"></div>
              <div class="curlHighlight" id="fxRightHi"></div>
            </div>
          </div>

          <div class="flipOverlay" id="flipLeft">
            <div class="pageImg" id="flipLeftImg"></div>
            <div class="curlFX">
              <div class="curlShadow" id="fxLeftShadow"></div>
              <div class="curlHighlight" id="fxLeftHi"></div>
            </div>
          </div>

          <div class="hit" id="hit"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------------- CONFIG ----------------
    const totalImages = 58;
    const folderPath = "images/";
    const extension = ".jpg";

    const TOTAL_SPEED = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--speed")) || 280;
    const HALF_SPEED = Math.max(60, Math.floor(TOTAL_SPEED / 2));
    const maxSpread = Math.ceil((totalImages + 1) / 2) - 1;

    // ---------------- ELEMENTS ----------------
    const frame = document.getElementById("frame");
    const dragWrapper = document.getElementById("drag-wrapper");

    const leftImg = document.getElementById("leftImg");
    const rightImg = document.getElementById("rightImg");

    const flipRight = document.getElementById("flipRight");
    const flipRightImg = document.getElementById("flipRightImg");
    const fxRightShadow = document.getElementById("fxRightShadow");
    const fxRightHi = document.getElementById("fxRightHi");

    const flipLeft = document.getElementById("flipLeft");
    const flipLeftImg = document.getElementById("flipLeftImg");
    const fxLeftShadow = document.getElementById("fxLeftShadow");
    const fxLeftHi = document.getElementById("fxLeftHi");

    const hit = document.getElementById("hit");

    // ---------------- PAN + ZOOM (stable pinch) ----------------
    const DRAG_THRESHOLD = 6;

    let scale = 1;
    let pos = { x: 0, y: 0 };

    // Smoothed targets (what the gesture wants)
    let targetScale = 1;
    let targetPos = { x: 0, y: 0 };

    // Animation smoothing strength (bigger = snappier)
    const SMOOTH = 0.22;

    // Pointer tracking
    const pointers = new Map(); // id -> {x,y, startX,startY}
    let wasDragged = false;
    let pinching = false;

    // Pinch reference state
    let pinchStartScale = 1;
    let pinchStartPos = { x: 0, y: 0 };
    let pinchStartDist = 1;

    // Extra pinch smoothing
    let filtMid = null;   // {x,y}
    let filtDist = null;  // number
    const PINCH_FILTER = 0.35; // higher = more smoothing

    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function applyTransform() {
      dragWrapper.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0) scale(${scale})`;
    }

    // Single RAF loop applies smoothing
    let rafRunning = false;
    function requestTick() {
      if (!rafRunning) {
        rafRunning = true;
        requestAnimationFrame(tick);
      }
    }

    function tick() {
      rafRunning = false;

      scale += (targetScale - scale) * SMOOTH;
      pos.x += (targetPos.x - pos.x) * SMOOTH;
      pos.y += (targetPos.y - pos.y) * SMOOTH;

      if (Math.abs(targetScale - scale) < 0.0005) scale = targetScale;
      if (Math.abs(targetPos.x - pos.x) < 0.05) pos.x = targetPos.x;
      if (Math.abs(targetPos.y - pos.y) < 0.05) pos.y = targetPos.y;

      applyTransform();

      if (Math.abs(targetScale - scale) > 0.0005 || Math.abs(targetPos.x - pos.x) > 0.05 || Math.abs(targetPos.y - pos.y) > 0.05) {
        requestTick();
      }
    }

    function setTargetTransform(newScale, newX, newY) {
      targetScale = clamp(newScale, 0.1, 6);
      targetPos.x = newX;
      targetPos.y = newY;
      requestTick();
    }

    function zoomToPointTarget(newScale, clientX, clientY, baseScale = targetScale, basePos = targetPos) {
      newScale = clamp(newScale, 0.1, 6);

      const px = clientX - window.innerWidth / 2;
      const py = clientY - window.innerHeight / 2;

      const newX = px - (px - basePos.x) * (newScale / baseScale);
      const newY = py - (py - basePos.y) * (newScale / baseScale);

      setTargetTransform(newScale, newX, newY);
    }

    function getMidAndDist(a, b) {
      const midX = (a.x + b.x) / 2;
      const midY = (a.y + b.y) / 2;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return { midX, midY, dist: Math.hypot(dx, dy) || 1 };
    }

    // Wheel zoom (ignore while touching)
    window.addEventListener("wheel", (e) => {
      if (pointers.size > 0) return;
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoomToPointTarget(targetScale * delta, e.clientX, e.clientY, targetScale, targetPos);
    }, { passive: false });

    // Pointer gestures for pan + pinch anywhere
    window.addEventListener("pointerdown", (e) => {
      try { e.target.setPointerCapture(e.pointerId); } catch (_) {}
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, startX: e.clientX, startY: e.clientY });
      wasDragged = false;

      if (pointers.size === 2) {
        pinching = true;

        const pts = Array.from(pointers.values());
        const { midX, midY, dist } = getMidAndDist(pts[0], pts[1]);

        pinchStartScale = targetScale;
        pinchStartPos = { x: targetPos.x, y: targetPos.y };
        pinchStartDist = dist;

        filtMid = { x: midX, y: midY };
        filtDist = dist;
      }
    }, { passive: false });

    window.addEventListener("pointermove", (e) => {
      const p = pointers.get(e.pointerId);
      if (!p) return;

      p.x = e.clientX;
      p.y = e.clientY;

      if (pointers.size === 2) {
        pinching = true;

        const pts = Array.from(pointers.values());
        const raw = getMidAndDist(pts[0], pts[1]);

        if (!filtMid) filtMid = { x: raw.midX, y: raw.midY };
        if (!filtDist) filtDist = raw.dist;

        // low-pass filter
        filtMid.x += (raw.midX - filtMid.x) * (1 - PINCH_FILTER);
        filtMid.y += (raw.midY - filtMid.y) * (1 - PINCH_FILTER);
        filtDist  += (raw.dist - filtDist)  * (1 - PINCH_FILTER);

        const ratio = (filtDist || 1) / (pinchStartDist || 1);
        const newScale = clamp(pinchStartScale * ratio, 0.1, 6);

        zoomToPointTarget(newScale, filtMid.x, filtMid.y, pinchStartScale, pinchStartPos);

        e.preventDefault();
        return;
      }

      // 1-finger pan
      if (pointers.size === 1 && !pinching) {
        const only = Array.from(pointers.values())[0];
        const dx = only.x - only.startX;
        const dy = only.y - only.startY;

        if (!wasDragged && Math.hypot(dx, dy) > DRAG_THRESHOLD) wasDragged = true;

        if (wasDragged) {
          const prev = p._prev || { x: only.x, y: only.y };
          const ddx = only.x - prev.x;
          const ddy = only.y - prev.y;
          p._prev = { x: only.x, y: only.y };

          setTargetTransform(targetScale, targetPos.x + ddx, targetPos.y + ddy);
          e.preventDefault();
        }
      }
    }, { passive: false });

    window.addEventListener("pointerup", (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) pinching = false;
      if (pointers.size === 0) setTimeout(() => { wasDragged = false; }, 50);
    }, { passive: false });

    window.addEventListener("pointercancel", (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) pinching = false;
    }, { passive: false });

    // ---------------- IMAGES ----------------
    function srcFor(index) {
      if (index < 0 || index >= totalImages) return null;
      return `${folderPath}${index}${extension}`;
    }
    function setBg(el, url) {
      el.style.backgroundImage = url ? `url("${url}")` : "none";
    }
    function spreadToIndices(spreadIndex) {
      const right = spreadIndex * 2;
      const left  = right - 1;
      return { left, right };
    }
    function renderSpread(i) {
      const { left, right } = spreadToIndices(i);
      setBg(leftImg, srcFor(left));
      setBg(rightImg, srcFor(right));
    }

    // ---- PRELOAD/DECODE CACHE (prevents black on first flip) ----
    const preloadCache = new Map();
    function preloadAndDecode(url) {
      if (!url) return Promise.resolve();
      if (preloadCache.has(url)) return preloadCache.get(url);

      const p = new Promise((resolve) => {
        const img = new Image();
        img.onload = async () => {
          if (img.decode) { try { await img.decode(); } catch (_) {} }
          resolve();
        };
        img.onerror = () => resolve();
        img.src = url;
      });
      preloadCache.set(url, p);
      return p;
    }
    function warmStart() {
      const urls = [];
      for (let i = 0; i < Math.min(totalImages, 10); i++) urls.push(srcFor(i));
      urls.forEach(u => preloadAndDecode(u));
    }

    // ---------------- PAGE TURN (sequential halves) ----------------
    let spreadIndex = 0;
    let animating = false;

    function easeInQuad(t){ return t * t; }
    function easeOutQuad(t){ return 1 - (1 - t) * (1 - t); }

    function setOverlay(overlayEl, side, origin, imgEl, imgUrl, scaleX){
      overlayEl.style.left = (side === "left") ? "0%" : "50%";
      overlayEl.style.transformOrigin = origin;
      setBg(imgEl, imgUrl);
      overlayEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX})`;
    }

    function setCurlFX(fold01, shadowEl, hiEl, dir){
      const mid = 1 - Math.abs(fold01 - 0.5) * 2;
      shadowEl.style.opacity = (0.22 + mid * 0.58).toFixed(3);
      hiEl.style.opacity     = (0.05 + mid * 0.22).toFixed(3);

      if (dir === "next") {
        hiEl.style.left = "0px";
        shadowEl.style.background = "linear-gradient(to left, rgba(0,0,0,0.80), rgba(0,0,0,0.0))";
      } else {
        hiEl.style.left = "calc(100% - 12px)";
        shadowEl.style.background = "linear-gradient(to right, rgba(0,0,0,0.80), rgba(0,0,0,0.0))";
      }
    }

    function resetOverlay(overlayEl, shadowEl, hiEl){
      overlayEl.style.transform = "translate3d(0,0,0) scaleX(0)";
      shadowEl.style.opacity = "0";
      hiEl.style.opacity = "0";
    }

    function animateHalf(overlayEl, fromSX, toSX, dirForFX, shadowEl, hiEl, easingFn){
      return new Promise((resolve) => {
        const start = performance.now();
        function tickAnim(now){
          const raw = Math.min(1, (now - start) / HALF_SPEED);
          const t = easingFn(raw);
          const sx = fromSX + (toSX - fromSX) * t;
          overlayEl.style.transform = `translate3d(0,0,0) scaleX(${sx})`;

          const folding = fromSX > toSX;
          const fold01 = folding ? t : (1 - t);
          setCurlFX(fold01, shadowEl, hiEl, dirForFX);

          if (raw < 1) requestAnimationFrame(tickAnim);
          else resolve();
        }
        requestAnimationFrame(tickAnim);
      });
    }

    async function next(){
      if (animating) return;
      if (spreadIndex >= maxSpread) return;
      animating = true;

      const curr = spreadIndex;
      const nextIdx = curr + 1;

      const currPair = spreadToIndices(curr);
      const nextPair = spreadToIndices(nextIdx);

      const currLeftUrl  = srcFor(currPair.left);
      const currRightUrl = srcFor(currPair.right);
      const nextLeftUrl  = srcFor(nextPair.left);
      const nextRightUrl = srcFor(nextPair.right);

      await Promise.all([preloadAndDecode(nextLeftUrl), preloadAndDecode(nextRightUrl)]);

      // Underlay setup
      setBg(leftImg, currLeftUrl);
      setBg(rightImg, nextRightUrl);

      // Phase A: fold current RIGHT page into spine
      setOverlay(flipRight, "right", "left center", flipRightImg, currRightUrl, 1);
      flipRight.style.zIndex = "70";
      await animateHalf(flipRight, 1, 0, "next", fxRightShadow, fxRightHi, easeInQuad);

      // Phase B: unfold new LEFT page from spine
      setOverlay(flipLeft, "left", "right center", flipLeftImg, nextLeftUrl, 0);
      flipLeft.style.zIndex = "71";
      await animateHalf(flipLeft, 0, 1, "prev", fxLeftShadow, fxLeftHi, easeOutQuad);

      spreadIndex = nextIdx;
      renderSpread(spreadIndex);

      resetOverlay(flipRight, fxRightShadow, fxRightHi);
      resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
      animating = false;

      // preload ahead
      const ahead = spreadToIndices(Math.min(maxSpread, spreadIndex + 1));
      preloadAndDecode(srcFor(ahead.left));
      preloadAndDecode(srcFor(ahead.right));
    }

    async function prev(){
      if (animating) return;
      if (spreadIndex <= 0) return;
      animating = true;

      const curr = spreadIndex;
      const prevIdx = curr - 1;

      const currPair = spreadToIndices(curr);
      const prevPair = spreadToIndices(prevIdx);

      const currLeftUrl  = srcFor(currPair.left);
      const currRightUrl = srcFor(currPair.right);
      const prevLeftUrl  = srcFor(prevPair.left);
      const prevRightUrl = srcFor(prevPair.right);

      await Promise.all([preloadAndDecode(prevRightUrl), preloadAndDecode(prevLeftUrl)]);

      // Underlay setup
      setBg(leftImg, prevLeftUrl);
      setBg(rightImg, currRightUrl);

      // Phase A: fold current LEFT page into spine
      setOverlay(flipLeft, "left", "right center", flipLeftImg, currLeftUrl, 1);
      flipLeft.style.zIndex = "70";
      await animateHalf(flipLeft, 1, 0, "prev", fxLeftShadow, fxLeftHi, easeInQuad);

      // Phase B: unfold previous RIGHT page from spine
      setOverlay(flipRight, "right", "left center", flipRightImg, prevRightUrl, 0);
      flipRight.style.zIndex = "71";
      await animateHalf(flipRight, 0, 1, "next", fxRightShadow, fxRightHi, easeOutQuad);

      spreadIndex = prevIdx;
      renderSpread(spreadIndex);

      resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
      resetOverlay(flipRight, fxRightShadow, fxRightHi);
      animating = false;

      // preload behind
      const behind = spreadToIndices(Math.max(0, spreadIndex - 1));
      preloadAndDecode(srcFor(behind.left));
      preloadAndDecode(srcFor(behind.right));
    }

    // Tap to flip (ignore if dragged/pinched)
    hit.addEventListener("click", (e) => {
      if (wasDragged || pinching) return;
      if (animating) return;

      const r = frame.getBoundingClientRect();
      const x = e.clientX - r.left;
      if (x > r.width / 2) next();
      else prev();
    });

    // ---------------- INIT ----------------
    renderSpread(spreadIndex);
    targetScale = scale;
    targetPos = { ...pos };
    applyTransform();
    resetOverlay(flipRight, fxRightShadow, fxRightHi);
    resetOverlay(flipLeft,  fxLeftShadow,  fxLeftHi);
    warmStart();
  </script>
</body>
</html>
